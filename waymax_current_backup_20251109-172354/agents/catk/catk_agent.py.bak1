import os
import jax
import jax.numpy as jnp
import numpy as np
import torch
from torch import Tensor
from torch_geometric.data import HeteroData
from typing import Optional, Callable, Tuple
from omegaconf import OmegaConf

from waymax import datatypes
from waymax.agents import catk_sim_agent
from waymax.datatypes.constant import TIME_INTERVAL

from waymax.agents.catk.smart.model.smart import SMART  # kept for reference
from waymax.agents.catk.smart.modules.smart_decoder import SMARTDecoder
from waymax.agents.catk.smart.tokens.token_processor import TokenProcessor


def _to_torch(x) -> Tensor:
    if isinstance(x, torch.Tensor):
        return x
    if hasattr(x, 'dtype') and 'jax' in type(x).__module__:
        x = jax.device_get(x)
    x = jnp.array(x)
    t = torch.from_numpy(x)
    return t


def _object_type_to_catk_types(obj_types_np: jnp.ndarray) -> torch.Tensor:
    # Waymax ObjectTypeIds: UNSET=0, VEHICLE=1, PEDESTRIAN=2, CYCLIST=3
    m = jnp.zeros_like(obj_types_np)
#     m[obj_types_np == 1] = 0  # veh
#     m[obj_types_np == 2] = 1  # ped
#     m[obj_types_np == 3] = 2  # cyc

    m = jnp.where(obj_types_np == 1, 0, m)
    m = jnp.where(obj_types_np == 2, 1, m)
    m = jnp.where(obj_types_np == 3, 2, m)

    m = m.astype(jnp.int64)
    return torch.from_numpy(jax.device_get(m).copy())
#     return torch.from_numpy(m.astype(jnp.int64))


class CATK_Simulator(catk_sim_agent.CATK_SimAgentActor):
    """CATK Simulator class."""

    def __init__(
        self,
        is_controlled_func: Optional[
            Callable[[datatypes.SimulatorState], jax.Array]
        ] = None,
        invalidate_on_end: bool = False,
        ckpt_path: Optional[str] = None,
    ):
        super().__init__(is_controlled_func=is_controlled_func)
        self.invalidate_on_end = invalidate_on_end

        # Device
        self.device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')

        # Load checkpoint config and weights
        if ckpt_path is None:
            root_path = os.environ.get('ROOT_PATH')
            if not root_path:
                raise ValueError(
                    'CATK_Simulator requires ROOT_PATH environment variable when ckpt_path is not provided'
                )
            ckpt_path = os.path.join(
                root_path, 'checkpoints', 'catk_trained_parameter', 'pre_bc_E31.ckpt'
            )
        ckpt = torch.load(ckpt_path, map_location='cpu')
        mc = ckpt['hyper_parameters']['model_config']
        self.model_config = mc

        # Build token processor and encoder
        self.token_processor = TokenProcessor(**mc['token_processor']).to(self.device)
        self.encoder = SMARTDecoder(
            n_token_agent=self.token_processor.n_token_agent,
            **mc['decoder'],
        ).to(self.device)
        self.encoder.eval()
        self.token_processor.eval()

        # Load weights: strip leading 'encoder.'
        enc_sd = {}
        for k, v in ckpt['state_dict'].items():
            if k.startswith('encoder.'):
                enc_sd[k[len('encoder.'):]] = v
        missing, unexpected = self.encoder.load_state_dict(enc_sd, strict=False)
        # Silence warnings in runtime; we only need decoder weights

        # Sampling scheme
        self.sampling_scheme = mc['validation_rollout_sampling']

    def update_trajectory(
        self, state: datatypes.SimulatorState
    ) -> datatypes.TrajectoryUpdate:
        """Returns a trajectory update of shape (..., num_objects, 1)."""
        next_traj = self._get_next_trajectory_by_projection(
            state,
        )
        return datatypes.TrajectoryUpdate(
            x=next_traj.x,
            y=next_traj.y,
            yaw=next_traj.yaw,
            vel_x=next_traj.vel_x,
            vel_y=next_traj.vel_y,
            valid=next_traj.valid,
        )

    def _build_map_tokens(self, state: datatypes.SimulatorState) -> Tuple[Tensor, Tensor, Tensor, Tensor]:
        rg = state.roadgraph_points
        # Shapes: (..., num_points)
        pos_xy = jax.device_get(rg.xy)
        dir_xy = jax.device_get(rg.dir_xy)
        types = jax.device_get(rg.types)
        valid = jax.device_get(rg.valid)
        ids = jax.device_get(rg.ids)

        pos_xy = jnp.array(pos_xy)
        dir_xy = jnp.array(dir_xy)
        types = jnp.array(types)
        valid = jnp.array(valid)
        ids = jnp.array(ids)

        # Flatten batch dims if exist; treat as one graph
        pos_xy = pos_xy.reshape(-1, pos_xy.shape[-2], 2)
        dir_xy = dir_xy.reshape(-1, dir_xy.shape[-2], 2)
        types = types.reshape(-1, types.shape[-1])
        valid = valid.reshape(-1, valid.shape[-1])
        ids = ids.reshape(-1, ids.shape[-1])

        pos_xy = pos_xy[0]
        dir_xy = dir_xy[0]
        types = types[0]
        valid = valid[0]
        ids = ids[0]

        mask = valid.astype(bool)
        pos_xy = pos_xy[mask]
        dir_xy = dir_xy[mask]
        types = types[mask]

        if pos_xy.shape[0] == 0:
            # Fallback to a single dummy polyline at origin
            traj_pos = torch.zeros((1, 3, 2), dtype=torch.float32)
            traj_theta = torch.zeros((1,), dtype=torch.float32)
            pt_type = torch.zeros((1,), dtype=torch.long)
            batch = torch.zeros((1,), dtype=torch.long)
            return traj_pos, traj_theta, pt_type, batch

        # Build 3-point polylines per roadgraph point using its direction
        d = 1.0
        dir_norm = jnp.linalg.norm(dir_xy, axis=-1, keepdims=True) + 1e-6
        dir_u = dir_xy / dir_norm
        p0 = pos_xy - d * dir_u
        p1 = pos_xy
        p2 = pos_xy + d * dir_u
        traj_pos_np = jnp.stack([p0, p1, p2], axis=1)  # [n_pl, 3, 2]
        traj_theta_np = jnp.arctan2(dir_u[:, 1], dir_u[:, 0])  # [n_pl]

#         traj_pos = torch.from_numpy(traj_pos_np.astype(jnp.float32).copy()).to(self.device)
        traj_pos = torch.from_numpy(jax.device_get(traj_pos_np.astype(jnp.float32)).copy()).to(self.device)
        traj_theta = torch.from_numpy(jax.device_get(traj_theta_np.astype(jnp.float32)).copy()).to(self.device)
        pt_type = torch.from_numpy(jax.device_get(types.astype(jnp.int64)).copy()).to(self.device)
        batch = torch.zeros((traj_pos.shape[0],), dtype=torch.long)
        return traj_pos, traj_theta, pt_type, batch

    def _state_to_heterodata(self, state: datatypes.SimulatorState) -> HeteroData:
        # Build agent tensors from log trajectory (host arrays)
        log = state.log_trajectory
        meta = state.object_metadata

        # Get full horizon arrays (shapes ~ [1, n_agent, n_step] for waymax pmapped state)
        x_all = np.array(jax.device_get(log.x))
        if not hasattr(self, "_log_shape_debug"):
            print("[CATK] log.x shape:", x_all.shape)
            self._log_shape_debug = True
        x = x_all.squeeze(0)           # [..., n_agent, n_step]
        y = np.array(jax.device_get(log.y)).squeeze(0)
        z = np.array(jax.device_get(log.z)).squeeze(0)
        yaw = np.array(jax.device_get(log.yaw)).squeeze(0)
        vel_x = np.array(jax.device_get(log.vel_x)).squeeze(0)
        vel_y = np.array(jax.device_get(log.vel_y)).squeeze(0)
        valid = np.array(jax.device_get(log.valid)).squeeze(0)
        length = np.array(jax.device_get(log.length)).squeeze(0)
        width  = np.array(jax.device_get(log.width)).squeeze(0)
        height = np.array(jax.device_get(log.height)).squeeze(0)

        if x.ndim == 2:
            x = np.expand_dims(x, axis=0)
            y = np.expand_dims(y, axis=0)
            z = np.expand_dims(z, axis=0)
            yaw = np.expand_dims(yaw, axis=0)
            vel_x = np.expand_dims(vel_x, axis=0)
            vel_y = np.expand_dims(vel_y, axis=0)
            valid = np.expand_dims(valid, axis=0)
            length = np.expand_dims(length, axis=0)
            width = np.expand_dims(width, axis=0)
            height = np.expand_dims(height, axis=0)
        n_graphs, n_agent_per_graph, n_step = x.shape
        n_agent_total = n_graphs * n_agent_per_graph

        # XY only for tokenizer inputs
        pos_xy = np.stack([x, y], axis=-1).astype(np.float32)        # [n_graphs, n_agent, n_step, 2]
        vel_xy = np.stack([vel_x, vel_y], axis=-1).astype(np.float32)
        heading = yaw.astype(np.float32)
        valid_mask = valid.astype(np.bool_)

        # Metadata
        obj_types = np.array(jax.device_get(meta.object_types)).squeeze(0)
        is_sdc = np.array(jax.device_get(meta.is_sdc)).squeeze(0).astype(bool)
        if hasattr(meta, 'objects_of_interest'):
            ooi = np.array(jax.device_get(meta.objects_of_interest)).squeeze(0).astype(bool)
        else:
            ooi = np.zeros_like(is_sdc, dtype=bool)
        ids = np.array(jax.device_get(meta.ids)).squeeze(0)

        agent_type = _object_type_to_catk_types(obj_types).reshape(-1)
        agent_id = torch.from_numpy(ids.astype(np.int64).reshape(-1))
        role = torch.stack([
            torch.from_numpy(is_sdc.astype(np.bool_).reshape(-1)),
            torch.from_numpy(ooi.astype(np.bool_).reshape(-1)),
            torch.from_numpy((~is_sdc & ~ooi).astype(np.bool_).reshape(-1)),
        ], dim=-1)

        # Use current step geometry from current_sim_trajectory (already dynamically sliced in simulator)
        cur = state.current_sim_trajectory
        cur_width_np = np.array(jax.device_get(cur.width))
        if not hasattr(self, "_cur_shape_debug"):
            print("[CATK] cur.width shape:", cur_width_np.shape)
            self._cur_shape_debug = True
        cur_width_np = cur_width_np.reshape(n_graphs, n_agent_per_graph, -1).astype(np.float32)[..., 0]
        cur_length_np = np.array(jax.device_get(cur.length)).reshape(n_graphs, n_agent_per_graph, -1).astype(np.float32)[..., 0]
        cur_height_np = np.array(jax.device_get(cur.height)).reshape(n_graphs, n_agent_per_graph, -1).astype(np.float32)[..., 0]
        cur_width = torch.from_numpy(cur_width_np.reshape(-1))
        cur_length = torch.from_numpy(cur_length_np.reshape(-1))
        cur_height = torch.from_numpy(cur_height_np.reshape(-1))
        shape = torch.stack([
            cur_width,
            cur_length,
            cur_height,
        ], dim=-1)

        # Build HeteroData
        data = HeteroData()
        data['agent'].num_nodes = int(n_agent_total)
        data['agent']['valid_mask'] = torch.from_numpy(
            valid_mask.reshape(n_graphs, n_agent_per_graph, n_step).reshape(n_agent_total, n_step)
        )
        data['agent']['role'] = role                                          # [n_agent, 3]
        data['agent']['id'] = agent_id                                        # [n_agent]
        data['agent']['type'] = agent_type                                    # [n_agent]
        data['agent']['position'] = torch.from_numpy(
            pos_xy.reshape(n_graphs, n_agent_per_graph, n_step, 2).reshape(n_agent_total, n_step, 2)
        )
        data['agent']['heading'] = torch.from_numpy(
            heading.reshape(n_graphs, n_agent_per_graph, n_step).reshape(n_agent_total, n_step)
        )
        data['agent']['velocity'] = torch.from_numpy(
            vel_xy.reshape(n_graphs, n_agent_per_graph, n_step, 2).reshape(n_agent_total, n_step, 2)
        )
        data['agent']['shape'] = shape                                        # [n_agent, 3]
        data['agent']['batch'] = torch.arange(n_graphs, dtype=torch.long).repeat_interleave(n_agent_per_graph)

        # Map tokens (already robust to empty)
        traj_pos, traj_theta, pt_type, batch = self._build_map_tokens(state)
        data['map_save'].num_nodes = int(traj_pos.shape[0])
        data['map_save']['traj_pos'] = traj_pos                               # [n_pl, 3, 2]
        data['map_save']['traj_theta'] = traj_theta                           # [n_pl]
        data['pt_token'].num_nodes = int(traj_pos.shape[0])
        data['pt_token']['type'] = pt_type
        data['pt_token']['pl_type'] = torch.zeros_like(pt_type)
        data['pt_token']['light_type'] = torch.zeros_like(pt_type)
        data['pt_token']['batch'] = batch

        data.num_graphs = n_graphs
        return data

    def _get_next_trajectory_by_projection(
        self,
        state: datatypes.SimulatorState,
    ) -> datatypes.Trajectory:
        """Run CAT-K to get the next trajectory for all agents."""
        if self.invalidate_on_end and bool(jax.device_get(state.is_done())):
            # Return invalid update
            cur = state.current_sim_trajectory
            invalid = jnp.zeros_like(cur.valid, dtype=jnp.bool_)
            return datatypes.Trajectory(
                x=cur.x, y=cur.y, z=cur.z, yaw=cur.yaw,
                vel_x=cur.vel_x, vel_y=cur.vel_y, valid=invalid,
                timestamp_micros=cur.timestamp_micros,
                length=cur.length, width=cur.width, height=cur.height,
            )

        data = self._state_to_heterodata(state)
        tokenized_map, tokenized_agent = self.token_processor(data)
        # Move to device
        tokenized_map = {
            k: v.to(self.device) if isinstance(v, torch.Tensor) else v
            for k, v in tokenized_map.items()
        }
        tokenized_agent = {
            k: v.to(self.device) if isinstance(v, torch.Tensor) else v
            for k, v in tokenized_agent.items()
        }

        with torch.no_grad():
            pred = self.encoder.inference(tokenized_map, tokenized_agent, self.sampling_scheme)
        pred_xy_10hz = pred.get('pred_traj_10hz')  # [n_agent, 80, 2]
        pred_head_10hz = pred.get('pred_head_10hz')  # [n_agent, 80]
        n_graphs = tokenized_agent["num_graphs"]
        n_agent_per_graph = tokenized_agent["type"].shape[0] // n_graphs

        # Current step xy for vel
        cur = state.current_sim_trajectory
        cur_x = jax.device_get(cur.x)[0, :, :, 0]
        cur_y = jax.device_get(cur.y)[0, :, :, 0]

        # Next step
        if pred_xy_10hz is None:
            # Fallback: keep current
            next_x = torch.from_numpy(cur_x.astype(jnp.float32))
            next_y = torch.from_numpy(cur_y.astype(jnp.float32))
            next_head = torch.from_numpy(
                jax.device_get(cur.yaw)[0, :, :, 0].astype(jnp.float32)
            )
        else:
            next_x = pred_xy_10hz[:, 0, 0].cpu().reshape(n_graphs, n_agent_per_graph)
            next_y = pred_xy_10hz[:, 0, 1].cpu().reshape(n_graphs, n_agent_per_graph)
            if pred_head_10hz is not None:
                next_head = pred_head_10hz[:, 0].cpu().reshape(
                    n_graphs, n_agent_per_graph
                )
            else:
                # Approximate from displacement if no head
                dx = next_x - torch.from_numpy(cur_x)
                dy = next_y - torch.from_numpy(cur_y)
                next_head = torch.atan2(dy, dx)

        # Velocity
        vx = (next_x - torch.from_numpy(cur_x)) / TIME_INTERVAL
        vy = (next_y - torch.from_numpy(cur_y)) / TIME_INTERVAL

        if not hasattr(self, "_traj_shape_debug"):
            print("[CATK] cur.x shape:", jax.device_get(cur.x).shape)
            self._traj_shape_debug = True
        base_shape = jax.device_get(cur.x).shape
        new_shape = base_shape
        x = jnp.asarray(next_x.numpy(), dtype=jnp.float32).reshape(new_shape)
        y = jnp.asarray(next_y.numpy(), dtype=jnp.float32).reshape(new_shape)
        yaw = jnp.asarray(next_head.numpy(), dtype=jnp.float32).reshape(new_shape)
        vx = jnp.asarray(vx.numpy(), dtype=jnp.float32).reshape(new_shape)
        vy = jnp.asarray(vy.numpy(), dtype=jnp.float32).reshape(new_shape)
        valid_mask = ~jax.device_get(state.object_metadata.is_sdc)
        valid = jnp.asarray(valid_mask, dtype=bool).reshape(new_shape)

        cur = state.current_sim_trajectory
        return datatypes.Trajectory(
            x=x, y=y, z=cur.z, yaw=yaw,
            vel_x=vx, vel_y=vy, valid=valid,
            timestamp_micros=cur.timestamp_micros,
            length=cur.length, width=cur.width, height=cur.height,
        )
